--- IMG_png.c	2009-11-08 12:55:32.000000000 +0200
+++ IMG_png.c.patched	2012-01-21 03:51:33.000000000 +0200
@@ -1,23 +1,22 @@
 /*
-    SDL_image:  An example image loading library for use with SDL
-    Copyright (C) 1997-2009 Sam Lantinga
+  SDL_image:  An example image loading library for use with SDL
+  Copyright (C) 1997-2012 Sam Lantinga <slouken@libsdl.org>
 
-    This library is free software; you can redistribute it and/or
-    modify it under the terms of the GNU Lesser General Public
-    License as published by the Free Software Foundation; either
-    version 2.1 of the License, or (at your option) any later version.
-
-    This library is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-    Lesser General Public License for more details.
-
-    You should have received a copy of the GNU Lesser General Public
-    License along with this library; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
-
-    Sam Lantinga
-    slouken@libsdl.org
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
 */
 
 #if !defined(__APPLE__) || defined(SDL_IMAGE_USE_COMMON_BACKEND)
@@ -71,6 +70,10 @@
 #endif
 #include <png.h>
 
+/* Check for the older version of libpng */
+#if (PNG_LIBPNG_VER_MAJOR == 1) && (PNG_LIBPNG_VER_MINOR < 4)
+#define LIBPNG_VERSION_12
+#endif
 
 static struct {
 	int loaded;
@@ -80,6 +83,8 @@
 	void (*png_destroy_read_struct) (png_structpp png_ptr_ptr, png_infopp info_ptr_ptr, png_infopp end_info_ptr_ptr);
 	png_uint_32 (*png_get_IHDR) (png_structp png_ptr, png_infop info_ptr, png_uint_32 *width, png_uint_32 *height, int *bit_depth, int *color_type, int *interlace_method, int *compression_method, int *filter_method);
 	png_voidp (*png_get_io_ptr) (png_structp png_ptr);
+	png_byte (*png_get_channels) (png_structp png_ptr, png_infop info_ptr);
+	png_uint_32 (*png_get_PLTE) (png_structp png_ptr, png_infop info_ptr, png_colorp *palette, int *num_palette);
 	png_uint_32 (*png_get_tRNS) (png_structp png_ptr, png_infop info_ptr, png_bytep *trans, int *num_trans, png_color_16p *trans_values);
 	png_uint_32 (*png_get_valid) (png_structp png_ptr, png_infop info_ptr, png_uint_32 flag);
 	void (*png_read_image) (png_structp png_ptr, png_bytepp image);
@@ -91,6 +96,9 @@
 	void (*png_set_read_fn) (png_structp png_ptr, png_voidp io_ptr, png_rw_ptr read_data_fn);
 	void (*png_set_strip_16) (png_structp png_ptr);
 	int (*png_sig_cmp) (png_bytep sig, png_size_t start, png_size_t num_to_check);
+#ifndef LIBPNG_VERSION_12
+	jmp_buf* (*png_set_longjmp_fn) (png_structp, png_longjmp_ptr, size_t);
+#endif
 } lib;
 
 #ifdef LOAD_PNG_DYNAMIC
@@ -129,6 +137,13 @@
 			SDL_UnloadObject(lib.handle);
 			return -1;
 		}
+		lib.png_get_channels =
+			(png_byte (*) (png_structp, png_infop))
+			SDL_LoadFunction(lib.handle, "png_get_channels");
+		if ( lib.png_get_channels == NULL ) {
+			SDL_UnloadObject(lib.handle);
+			return -1;
+		}
 		lib.png_get_io_ptr =
 			(png_voidp (*) (png_structp))
 			SDL_LoadFunction(lib.handle, "png_get_io_ptr");
@@ -136,6 +151,13 @@
 			SDL_UnloadObject(lib.handle);
 			return -1;
 		}
+		lib.png_get_PLTE =
+			(png_uint_32 (*) (png_structp, png_infop, png_colorp *, int *))
+			SDL_LoadFunction(lib.handle, "png_get_PLTE");
+		if ( lib.png_get_PLTE == NULL ) {
+			SDL_UnloadObject(lib.handle);
+			return -1;
+		}
 		lib.png_get_tRNS =
 			(png_uint_32 (*) (png_structp, png_infop, png_bytep *, int *, png_color_16p *))
 			SDL_LoadFunction(lib.handle, "png_get_tRNS");
@@ -213,6 +235,15 @@
 			SDL_UnloadObject(lib.handle);
 			return -1;
 		}
+#ifndef LIBPNG_VERSION_12
+		lib.png_set_longjmp_fn =
+			(jmp_buf * (*) (png_structp, png_longjmp_ptr, size_t))
+			SDL_LoadFunction(lib.handle, "png_set_longjmp_fn");
+		if ( lib.png_set_longjmp_fn == NULL ) {
+			SDL_UnloadObject(lib.handle);
+			return -1;
+		}
+#endif
 	}
 	++lib.loaded;
 
@@ -236,7 +267,9 @@
 		lib.png_create_read_struct = png_create_read_struct;
 		lib.png_destroy_read_struct = png_destroy_read_struct;
 		lib.png_get_IHDR = png_get_IHDR;
+		lib.png_get_channels = png_get_channels;
 		lib.png_get_io_ptr = png_get_io_ptr;
+		lib.png_get_PLTE = png_get_PLTE;
 		lib.png_get_tRNS = png_get_tRNS;
 		lib.png_get_valid = png_get_valid;
 		lib.png_read_image = png_read_image;
@@ -248,6 +281,9 @@
 		lib.png_set_read_fn = png_set_read_fn;
 		lib.png_set_strip_16 = png_set_strip_16;
 		lib.png_sig_cmp = png_sig_cmp;
+#ifndef LIBPNG_VERSION_12
+		lib.png_set_longjmp_fn = png_set_longjmp_fn;
+#endif
 	}
 	++lib.loaded;
 
@@ -303,7 +339,7 @@
 	png_structp png_ptr;
 	png_infop info_ptr;
 	png_uint_32 width, height;
-	int bit_depth, color_type, interlace_type;
+	int bit_depth, color_type, interlace_type, num_channels;
 	Uint32 Rmask;
 	Uint32 Gmask;
 	Uint32 Bmask;
@@ -347,7 +383,12 @@
 	 * the normal method of doing things with libpng).  REQUIRED unless you
 	 * set up your own error handlers in png_create_read_struct() earlier.
 	 */
-	if ( setjmp(png_ptr->jmpbuf) ) {
+#ifndef LIBPNG_VERSION_12
+	if ( setjmp(*lib.png_set_longjmp_fn(png_ptr, longjmp, sizeof (jmp_buf))) )
+#else
+	if ( setjmp(png_ptr->jmpbuf) )
+#endif
+	{
 		error = "Error reading the PNG file.";
 		goto done;
 	}
@@ -410,15 +451,16 @@
 			&color_type, &interlace_type, NULL, NULL);
 
 	/* Allocate the SDL surface to hold the image */
-	Rmask = Gmask = Bmask = Amask = 0 ; 
+	Rmask = Gmask = Bmask = Amask = 0 ;
+	num_channels = lib.png_get_channels(png_ptr, info_ptr);
 	if ( color_type != PNG_COLOR_TYPE_PALETTE ) {
 		if ( SDL_BYTEORDER == SDL_LIL_ENDIAN ) {
 			Rmask = 0x000000FF;
 			Gmask = 0x0000FF00;
 			Bmask = 0x00FF0000;
-			Amask = (info_ptr->channels == 4) ? 0xFF000000 : 0;
+			Amask = (num_channels == 4) ? 0xFF000000 : 0;
 		} else {
-		        int s = (info_ptr->channels == 4) ? 0 : 8;
+			int s = (num_channels == 4) ? 0 : 8;
 			Rmask = 0xFF000000 >> s;
 			Gmask = 0x00FF0000 >> s;
 			Bmask = 0x0000FF00 >> s;
@@ -426,7 +468,7 @@
 		}
 	}
 	surface = SDL_AllocSurface(SDL_SWSURFACE, width, height,
-			bit_depth*info_ptr->channels, Rmask,Gmask,Bmask,Amask);
+			bit_depth*num_channels, Rmask,Gmask,Bmask,Amask);
 	if ( surface == NULL ) {
 		error = "Out of memory";
 		goto done;
@@ -467,6 +509,9 @@
 	/* Load the palette, if any */
 	palette = surface->format->palette;
 	if ( palette ) {
+	    int png_num_palette;
+	    png_colorp png_palette;
+	    lib.png_get_PLTE(png_ptr, info_ptr, &png_palette, &png_num_palette);
 	    if(color_type == PNG_COLOR_TYPE_GRAY) {
 		palette->ncolors = 256;
 		for(i = 0; i < 256; i++) {
@@ -474,12 +519,12 @@
 		    palette->colors[i].g = i;
 		    palette->colors[i].b = i;
 		}
-	    } else if (info_ptr->num_palette > 0 ) {
-		palette->ncolors = info_ptr->num_palette; 
-		for( i=0; i<info_ptr->num_palette; ++i ) {
-		    palette->colors[i].b = info_ptr->palette[i].blue;
-		    palette->colors[i].g = info_ptr->palette[i].green;
-		    palette->colors[i].r = info_ptr->palette[i].red;
+	    } else if (png_num_palette > 0 ) {
+		palette->ncolors = png_num_palette; 
+		for( i=0; i<png_num_palette; ++i ) {
+		    palette->colors[i].b = png_palette[i].blue;
+		    palette->colors[i].g = png_palette[i].green;
+		    palette->colors[i].r = png_palette[i].red;
 		}
 	    }
 	}
